<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Abusing Azure Arc: From Service Principal Exposed to Reverse Shell - XYBYTES</title>

  <!-- Edit site and author settings in `_config.yml` to make the social details your own -->

    <meta content="XYBYTES" property="og:site_name">
  
    <meta content="Abusing Azure Arc: From Service Principal Exposed to Reverse Shell" property="og:title">
  
  
    <meta content="article" property="og:type">
  
  
    <meta content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
" property="og:description">
  
  
    <meta content="http://localhost:4000/Abusing-Azure-Arc/" property="og:url">
  
  
    <meta content="2024-06-16T12:32:20+02:00" property="article:published_time">
    <meta content="http://localhost:4000/about/" property="article:author">
  
  
    <meta content="http://localhost:4000/flexible-jekyll/assets/img/christian-bortone.jpg" property="og:image">
  
  
    
  
  
    
  

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@xybytes">
  
    <meta name="twitter:title" content="Abusing Azure Arc: From Service Principal Exposed to Reverse Shell">
  
  
    <meta name="twitter:url" content="http://localhost:4000/Abusing-Azure-Arc/">
  
  
    <meta name="twitter:description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
">
  
  
    <meta name="twitter:image:src" content="http://localhost:4000/flexible-jekyll/assets/img/christian-bortone.jpg">
  

	<meta name="description" content="">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta property="og:image" content="">
	<link rel="shortcut icon" href="/flexible-jekyll/assets/img/favicon/favicon.ico" type="image/x-icon">
	<link rel="apple-touch-icon" href="/flexible-jekyll/assets/img/favicon/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/flexible-jekyll/assets/img/favicon/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="144x144" href="/flexible-jekyll/assets/img/favicon/apple-touch-icon-144x144.png">
	<!-- Chrome, Firefox OS and Opera -->
	<meta name="theme-color" content="#263959">
	<!-- Windows Phone -->
	<meta name="msapplication-navbutton-color" content="#263959">
	<!-- iOS Safari -->
	<meta name="apple-mobile-web-app-status-bar-style" content="#263959">
	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=PT+Serif:400,700|Lato:300,400,700&display=swap" rel="stylesheet">
	<!-- Font Awesome -->
	<link rel="stylesheet" href="/flexible-jekyll/assets/fonts/font-awesome/css/font-awesome.min.css">
	<!-- Styles -->
	<link rel="stylesheet" href="/flexible-jekyll/assets/css/main.css">
</head>

<body>

  <div class="wrapper">
    <aside class="sidebar">
  <header>
    <div class="about">
      <div class="cover-author-image">
        <a href="/flexible-jekyll/"
          ><img
            src="/flexible-jekyll/assets/img/christian-bortone.jpg"
            alt="Christian Bortone"
        /></a>
      </div>
      <div class="author-name">Christian Bortone</div>
      <p>I am penetration tester and security researcher in my free time. I enjoy diving deep into Active Directory, Azure, and uncovering undocumented aspects of Microsoft technologies.</p>
    </div>
  </header>
  <!-- End Header -->
  <footer>
    <section class="contact">
      <h3 class="contact-title">Contact me</h3>
      <ul>
        
        <li>
          <a
            href="https://twitter.com/xybytes"
            target="_blank"
            ><i class="fa fa-twitter" aria-hidden="true"></i
          ></a>
        </li>
         
        <li class="github">
          <a href="http://github.com/xybytes" target="_blank"
            ><i class="fa fa-github"></i
          ></a>
        </li>
         
        <li class="linkedin">
          <a
            href="https://in.linkedin.com/in/christianbortone"
            target="_blank"
            ><i class="fa fa-linkedin"></i
          ></a>
        </li>
         
        <li class="email">
          <a href="mailto:christianbortone@gmail.com"
            ><i class="fa fa-envelope-o"></i
          ></a>
        </li>
        
      </ul>
    </section>
    <!-- End Section Contact -->
    <div class="copyright">
      <p>2024 &copy; Christian Bortone</p>
    </div>
  </footer>
  <!-- End Footer -->
</aside>
<!-- End Sidebar -->
<div class="content-box clearfix"><article class="article-page">
  <div class="page-content">
     
    <div class="wrap-content">
      <header class="header-page">
        <h1 class="page-title">Abusing Azure Arc: From Service Principal Exposed to Reverse Shell</h1>
        <div class="page-date">
          <span>2024, Jun 16&nbsp;&nbsp;&nbsp;&nbsp;</span>
        </div>
      </header>
      <p>Over the past year, I have been experimenting with Azure Arc service. I found it to be a fascinating service that combines and extends the internal and on-premises environments, merging them with the cloud. I believed it would be an intriguing service to explore from a security standpoint, and my intuition proved to be correct. I had the opportunity to present this new attack vector at Bsides Leeds 2024, and in this article, I will delve into greater detail on how this miscofiguration can be utilized by malicious actors to transition from the on-premises environment to Azure, and subsequently compromise all the machines connected to Azure Arc.</p>

<h2 id="what-is-azure-arc">What is Azure Arc?</h2>

<p>Azure Arc is an innovative hybrid cloud platform that empowers users to control and monitor a wide range of servers and databases. This includes traditional Linux and Windows servers located on-premises environment, databases and virtual machines operating in different public clouds. Azure Arc uses Azure’s built-in functionalities to easily manage resources in different locations from a central control point.</p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/azure_arc_overview.png" alt="Azure Arc Overview" /></p>

<p>To onboard a new machine in Azure Arc, we must generate a new service principal. This service principal will serve as the authentication entity, allowing the machine to connect to Azure and be enrolled in Azure Arc. Ensure the service principal is assigned at least the <em>Azure Connected Machine Onboarding</em> role.</p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/sp_01.png" alt="SP_01" /></p>

<p>In this case, we assume that the system administrators are not following the principle of least privilege as they have assigned the roles of <em>Azure Connected Machine Onboarding</em> and <em>Azure Connected Machine Resource Administrator</em> to the service principal.</p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/sp_roles.png" alt="SP Role" /></p>

<h2 id="add-servers-with-azure-arc">Add Servers with Azure Arc</h2>

<p>Three choices exist for including a new machine. Our emphasis is on <em>Adding multiple servers</em>.</p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/add_machine_01.png" alt="Add machine" /></p>

<p>To integrate a new internal server (a joined domain server) into Azure Arc, we will utilize GPO. Before we can onboard new machines using this method, it is crucial to have the installer, <em>AzureConnectedMachineAgent.msi</em>, stored in a shared location that can be accessed by the target machines. This information is detailed in point 2, which specifies the requirement for a remote share to host the Windows Installer package. It is important to ensure that the Domain Controllers, Computers, and Admins all have change permissions for the network share. Once everything is properly set up, we can proceed to download the package and save it to the remote share. By utilizing this method, the onboarding process will automatically begin once the new GPO is applied.</p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/add_machine_02.png" alt="Add machine" /></p>

<p>Furthermore, Microsoft provides a deployment toolkit that must be utilized to initiate the onboarding procedure.</p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/deploy_github_kit.png" alt="Add machine" /></p>

<p>Inside the <em>ArcEnableServerGroupPolicy.zip</em> file, we will find the following scripts: <em>DeployGPO.ps1</em>, <em>EnableAzureArc.ps1</em>, and <em>AzureArcDeployment.psm1</em>.</p>

<h3 id="deploygpops1">DeployGPO.ps1</h3>

<p>This script needs to be executed on a Domain Controller and performs the following actions:</p>

<ol>
  <li>Deploys the Azure Arc Servers Onboarding GPO in the local domain</li>
  <li>Copies the EnableAzureArc.ps1 onboarding script to the network Share</li>
</ol>

<p>When we run this script, we pass two main parameters: <em>ServicePrincipalId</em> and <em>ServicePrincipalClientSecret</em>. Additionally, we provide other parameters such as the domain (e.g., <em>xybytes.com</em>), the server where the share is stored (e.g., <em>dc01.xybytes.com</em>), and the name of the share (<em>ArcOnboardShare</em> in this case). We also include further details like the tenant ID, resource group, and other necessary information.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ServicePrincipalId</span><span class="o">=</span><span class="s2">"5bc8bc98-6307-407b-adde-07a3425b90d7"</span><span class="p">;</span><span class="w">
</span><span class="nv">$ServicePrincipalClientSecret</span><span class="o">=</span><span class="s2">"eGm8Q~6ujDQiVh7LKaKsvmM2Cph73eqLL38lRdlm"</span><span class="p">;</span><span class="w">

</span><span class="o">.</span><span class="n">\DeployGPO.ps1</span><span class="w"> </span><span class="nt">-DomainFQDN</span><span class="w"> </span><span class="nx">xybytes.com</span><span class="w"> </span><span class="nt">-ReportServerFQDN</span><span class="w"> </span><span class="s2">"dc01.xybytes.com"</span><span class="w"> </span><span class="nt">-ArcRemoteShare</span><span class="w"> </span><span class="nx">ArcOnboardShare</span><span class="w"> </span><span class="nt">-ServicePrincipalSecret</span><span class="w"> </span><span class="nv">$ServicePrincipalClientSecret</span><span class="w"> </span><span class="nt">-ServicePrincipalClientId</span><span class="w"> </span><span class="nv">$ServicePrincipalId</span><span class="w"> </span><span class="nt">-SubscriptionId</span><span class="w"> </span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="w"> </span><span class="nt">-ResourceGroup</span><span class="w"> </span><span class="nx">AzureArcLAB</span><span class="w"> </span><span class="nt">-Location</span><span class="w"> </span><span class="nx">westeurope</span><span class="w"> </span><span class="nt">-TenantId</span><span class="w"> </span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>After running the script, we can verify the GPO created in the Active Directory environment. Once this GPO is applied, the machines will automatically initiate the onboarding process to Azure Arc.</p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/GPO_created.png" alt="GPO" /></p>

<h3 id="enableazurearcps1">EnableAzureArc.ps1</h3>

<p>During the onboarding process, this script is executed by machines and performs the following validation checks:</p>

<ol>
  <li>Checks if the machine is an Azure VM or a non-Azure machine.</li>
  <li>Checks the Framework version.</li>
  <li>Checks the PowerShell version.</li>
</ol>

<p>If the server fails to meet the specified requirements, all pertinent details, including the operating system, framework version, PowerShell version, VM type, and other relevant information, are saved on a network share for subsequent analysis. In the event that the server satisfies the requirements, the script continues with the following steps:</p>

<ol>
  <li>Checks if the Azure Hybrid Instance Metadata Service is already installed.</li>
  <li>If not installed:
    <ul>
      <li>Installs the Connected Machine agent on the machine.</li>
      <li>Connects the server to Azure Arc using a Service Principal.</li>
      <li>Tags the Azure Arc server with a given tag.</li>
    </ul>
  </li>
  <li>Logs any connection errors and the agent code.</li>
  <li>Verifies the connection status.</li>
</ol>

<h3 id="azurearcdeploymentpsm1">AzureArcDeployment.psm1</h3>

<p>Wrapper for DPAPI-NG features</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Add-Type</span><span class="w"> </span><span class="nt">-TypeDefinition</span><span class="w"> </span><span class="sh">@"
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
public static class DpapiNgUtil
{
public static string ProtectBase64(string protectionDescriptor, string input)
{
byte[] output = Protect(protectionDescriptor, Encoding.UTF8.GetBytes(input));
return Convert.ToBase64String(output);
}
public static string UnprotectBase64(string input)
[...]
</span></code></pre></div></div>

<h2 id="where-is-the-secret-stored-and-how-is-it-protected">Where is the secret stored, and how is it protected?</h2>

<p>While experimenting with Azure Arc, I was curious about the location of the service principal secret. Since machines joining Azure must authenticate to the cloud, they require access to this secret. After some investigation, I found that the secret is stored in a file within the network shared directory named <code class="language-plaintext highlighter-rouge">AzureArcDeploy</code>.</p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/encrypted_SP_00.png" alt="enc_sp_00" /></p>

<p>The challenge at hand is that this particular secret is encrypted and cannot be decrypted by a regular user.</p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/encrypted_SP_01.png" alt="enc_sp_01" /></p>

<p>The secret is encrypted using DPAPI-NG, a security feature introduced by Microsoft in Windows 8 and Server 2012 R2. DPAPI-NG enhances the security framework, allowing for the secure sharing of secrets across different users and machines. This means that encrypted secrets with a user or computer account can be decrypted by another user. However, it’s worth mentioning that DPAPI-NG decryption is limited to calls made through the MS-GKDI interface, which necessitates network access to a domain controller.</p>

<p>The proof that this secret is encrypted with DPAPI-NG can be found in the <em>DeployGPO.ps1</em> script. Specifically, the following line of code performs the encryption by calling the <em>ProtectBase64</em> function, passing the <em>$descriptor</em> and <em>$ServicePrincipalSecret</em> as inputs. In this case, the descriptor is composed of the Domain Computer and the Domain Controller group SID. This means, as explained in the comments, that the <em>ServicePrincipalSecret</em> can only be decrypted by the Domain Controllers and the Domain Computers security groups.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Encrypting the ServicePrincipalSecret to be decrypted only by the Domain Controllers and the Domain Computers security groups</span><span class="w">
</span><span class="nv">$DomainComputersSID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"SID="</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">$DomainComputersSID</span><span class="w">
</span><span class="nv">$DomainControllersSID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"SID="</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">$DomainControllersSID</span><span class="w">
</span><span class="nv">$descriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">@(</span><span class="nv">$DomainComputersSID</span><span class="p">,</span><span class="w"> </span><span class="nv">$DomainControllersSID</span><span class="p">)</span><span class="w"> </span><span class="o">-join</span><span class="w"> </span><span class="s2">" OR "</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="bp">$PSScriptRoot</span><span class="nx">\AzureArcDeployment.psm1</span><span class="w">
</span><span class="nv">$encryptedSecret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">DpapiNgUtil</span><span class="p">]::</span><span class="n">ProtectBase64</span><span class="p">(</span><span class="nv">$descriptor</span><span class="p">,</span><span class="w"> </span><span class="nv">$ServicePrincipalSecret</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>This poses a significant security risk if this script is not modified and left with its default settings. In this scenario, any machine account in the Domain Computers group can decrypt this secret. From an attack perspective, it is not very difficult to create a new machine account in a vulnerable environment, for example, through <em>machine account quota</em> misconfiguration, and use it to decrypt the service principal secret.</p>

<p>Indeed, upon inspecting the <em>EnableAzureArc.ps1</em> script, it becomes apparent that the script leverages the <em>UnprotectBase64</em> function for decrypting the secret. As this function is executed by the machine, it possesses the required privileges to successfully decrypt the secret.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">Function</span><span class="w"> </span><span class="nf">Get-ServicePrincipalSecret</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="kr">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="n">Copy-Item</span><span class="w"> </span><span class="p">(</span><span class="n">Join-Path</span><span class="w"> </span><span class="nv">$SourceFilesFullPath</span><span class="w"> </span><span class="s2">"AzureArcDeployment.psm1"</span><span class="p">)</span><span class="w"> </span><span class="nv">$workfolder</span><span class="w"> </span><span class="nt">-Force</span><span class="w">
</span><span class="n">Import-Module</span><span class="w"> </span><span class="p">(</span><span class="n">Join-Path</span><span class="w"> </span><span class="nv">$workfolder</span><span class="w"> </span><span class="s2">"AzureArcDeployment.psm1"</span><span class="p">)</span><span class="w">
</span><span class="nv">$encryptedSecret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Get-Content</span><span class="w"> </span><span class="p">(</span><span class="n">Join-Path</span><span class="w"> </span><span class="nv">$SourceFilesFullPath</span><span class="w"> </span><span class="nx">encryptedServicePrincipalSecret</span><span class="p">)</span><span class="w">
</span><span class="nv">$sps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">DpapiNgUtil</span><span class="p">]::</span><span class="n">UnprotectBase64</span><span class="p">(</span><span class="nv">$encryptedSecret</span><span class="p">)</span><span class="w">
</span><span class="n">Remove-Item</span><span class="w"> </span><span class="p">(</span><span class="n">Join-Path</span><span class="w"> </span><span class="nv">$workfolder</span><span class="w"> </span><span class="s2">"AzureArcDeployment.psm1"</span><span class="p">)</span><span class="w"> </span><span class="nt">-Force</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="kr">catch</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="n">Write-Log</span><span class="w"> </span><span class="nt">-msg</span><span class="w"> </span><span class="s2">"Could not fetch service principal secret: </span><span class="si">$(</span><span class="bp">$_</span><span class="o">.</span><span class="nf">Exception</span><span class="si">)</span><span class="s2">"</span><span class="w"> </span><span class="nt">-msgtype</span><span class="w"> </span><span class="nx">ERROR</span><span class="w">
</span><span class="kr">return</span><span class="w"> </span><span class="bp">$false</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="kr">return</span><span class="w"> </span><span class="nv">$sps</span><span class="w">
</span></code></pre></div></div>

<h2 id="lets-exploit-it">Let’s Exploit It!</h2>

<p>We assume the perspective of an attacker:</p>

<ol>
  <li>We have successfully penetrated the internal network.</li>
  <li>We have taken control of the user account <em>xybytes\chris</em> within Active Directory.</li>
  <li>We have discovered a network share containing the <em>AzureArcDeploy</em> directory.</li>
</ol>

<p>In order to ensure that the <em>machine account quota</em> is set to its default configuration, our priority is to verify if a regular user can create up to 10 machine accounts.</p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/machine_accout_quote.png" alt="machine account quote" /></p>

<p>We can now import <em>powermad.ps1</em> to create a new machine account <em>fake01</em>.</p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/powermad.png" alt="powermad" /></p>

<p>At this stage, we need to authenticate using this account. We can either utilize the <em>runas.exe</em> command with the <em>netonly</em> flag or opt for the pass-the-ticket method using <em>Rubeus.exe</em>. Let’s proceed with the latter option.</p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/rubeus.png" alt="rubeus" /></p>

<p>By having the TGT for FAKE01 stored in memory, we can use the following script (<em>dec.ps1</em>) to decrypt the service principal secret.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\AzureArcDeployment.psm1</span><span class="w">

</span><span class="nv">$encryptedSecret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Get-Content</span><span class="w"> </span><span class="s2">"\\dc01\ArcOnboardShare\AzureArcDeploy\encryptedServicePrincipalSecret"</span><span class="w">

</span><span class="nv">$ebs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">DpapiNgUtil</span><span class="p">]::</span><span class="n">UnprotectBase64</span><span class="p">(</span><span class="nv">$encryptedSecret</span><span class="p">)</span><span class="w">
</span><span class="nv">$ebs</span><span class="w">
</span></code></pre></div></div>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/dec.png" alt="dec" /></p>

<p>At this point, we can gather the remaining information needed to connect to Azure from the <em>ArcInfo.json</em> file, which is stored on the same network share as the <em>encryptedServicePrincipalSecret</em> file. This file contains details such as: TenantId, servicePrincipalClientId, ResourceGroup, and more. With this information, we can use Azure CLI to authenticate as the compromised service principal and begin enumerating machines that are joined to Azure Arc.</p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/shell_01.png" alt="shell01" /></p>

<p>In the example above, we got a reverse shell from a server we discovered, named <em>server01</em>, using a base64-encoded PowerShell reverse shell.</p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/shell_02.png" alt="shell02" /></p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/shell_03.png" alt="shell02" /></p>

<p><img src="/flexible-jekyll/assets/img/Azure_Arc/shell_04.png" alt="shell03" /></p>

<h3 id="defenses-and-remediations">Defenses and Remediations</h3>

<p>Azure Arc introduces a new potential vulnerability for malicious actors, enabling them to transition from on-premises environments to the cloud. It is crucial to thoroughly review any Microsoft deployment script before executing it in a production environment and network. Be mindful that if the deployment script uses the default configuration, any machine account in the Domain Computers group could access the service principal secret. To enhance security, we can create a dedicated group in Active Directory containing only the machines you plan to connect to Azure Arc. By incorporating this specific SID into the DeployGPO script, we can prevent unauthorized machine accounts from accessing the service principal secret, thereby reducing the risk of potential exploits. Additionally, it is important to limit the privileges of the service principal secret by following the principle of least privilege. This ensures that even if the secret is compromised, the attacker cannot run command to other Azure Arc joined VMs.</p>

      <!--   <div class="page-footer">
          <div class="page-tag">
          
        </div> 
      </div> -->
    </div>
    <!-- End Wrap Content -->
  </div>
  <!-- End Page Content -->
</article>
<!-- End Article Page -->
</div>

  </div>
  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '', 'auto');
  ga('send', 'pageview');
</script> <!-- End Analytics -->

</body>
</html>
